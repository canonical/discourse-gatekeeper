# Copyright 2023 Canonical Ltd.
# See LICENSE file for licensing details.

"""Module for handling interactions with git repository."""

import base64
import logging
import re
from contextlib import suppress
from pathlib import Path

from git import GitCommandError
from git.repo import Repo
from github import Github
from github.GithubException import GithubException, UnknownObjectException
from github.Repository import Repository

from .constants import DOCUMENTATION_FOLDER_NAME
from .exceptions import (
    InputError,
    RepositoryClientError,
    RepositoryFileNotFoundError,
    RepositoryTagNotFoundError,
)

GITHUB_HOSTNAME = "github.com"
ORIGIN_NAME = "origin"
HTTPS_URL_PATTERN = re.compile(rf"^https?:\/\/.*@?{GITHUB_HOSTNAME}\/(.+\/.+?)(.git)?$")
ACTIONS_USER_NAME = "upload-charms-docs-bot"
ACTIONS_USER_EMAIL = "upload-charms-docs-bot@users.noreply.github.com"
ACTIONS_PULL_REQUEST_TITLE = "[upload-charm-docs] Migrate charm docs"
ACTIONS_PULL_REQUEST_BODY = (
    "This pull request was autogenerated by upload-charm-docs to migrate "
    "existing documentation from server to the git repository."
)
PR_LINK_NO_CHANGE = "<not created due to no changes in repository>"
TAG_MESSAGE = (
    "tag created by upload-charm-docs to mark the latest push to discourse, managed by "
    "upload-charm-docs, changes or removal of this tag may lead to unexpected behaviour"
)

CONFIG_USER_SECTION_NAME = "user"
CONFIG_USER_NAME = (CONFIG_USER_SECTION_NAME, "name")
CONFIG_USER_EMAIL = (CONFIG_USER_SECTION_NAME, "email")


class Client:
    """Wrapper for git/git-server related functionalities."""

    def __init__(self, repository: Repo, github_repository: Repository) -> None:
        """Construct.

        Args:
            repository: Client for interacting with local git repository.
            github_repository: Client for interacting with remote github repository.
        """
        self._git_repo = repository
        self._github_repo = github_repository
        self._configure_git_user()

    def _configure_git_user(self) -> None:
        """Configure action git profile defaults.

        Configured profile appears as the git committer.
        """
        config_reader = self._git_repo.config_reader(config_level="repository")
        with self._git_repo.config_writer(config_level="repository") as config_writer:
            if not config_reader.has_section(
                CONFIG_USER_SECTION_NAME
            ) or not config_reader.get_value(*CONFIG_USER_NAME):
                config_writer.set_value(*CONFIG_USER_NAME, ACTIONS_USER_NAME)
            if not config_reader.has_section(
                CONFIG_USER_SECTION_NAME
            ) or not config_reader.get_value(*CONFIG_USER_EMAIL):
                config_writer.set_value(*CONFIG_USER_EMAIL, ACTIONS_USER_EMAIL)

    def check_branch_exists(self, branch_name: str) -> bool:
        """Check if branch exists on remote.

        Args:
            branch_name: Branch name to check on remote.

        Raises:
            RepositoryClientError: if unexpected error occurred during git operation.

        Returns:
            True if branch already exists, False otherwise.
        """
        try:
            self._git_repo.git.fetch(ORIGIN_NAME, branch_name)
            return True
        except GitCommandError as exc:
            if "couldn't find remote ref" in exc.stderr:
                return False
            raise RepositoryClientError(
                f"Unexpected error checking existing branch. {exc=!r}"
            ) from exc

    def create_branch(self, branch_name: str, commit_msg: str) -> None:
        """Create new branch with existing changes using the default branch as the base.

        Args:
            branch_name: New branch name.
            commit_msg: Commit message for current changes.

        Raises:
            RepositoryClientError: if unexpected error occurred during git operation.
        """
        default_branch = self._github_repo.default_branch
        try:
            self._git_repo.git.fetch(ORIGIN_NAME, default_branch)
            self._git_repo.git.checkout(default_branch, "--")
            self._git_repo.git.checkout("-b", branch_name)
            self._git_repo.git.add("-A", DOCUMENTATION_FOLDER_NAME)
            self._git_repo.git.commit("-m", f"'{commit_msg}'")
            self._git_repo.git.push("-u", ORIGIN_NAME, branch_name)
        except GitCommandError as exc:
            raise RepositoryClientError(f"Unexpected error creating new branch. {exc=!r}") from exc

    def create_pull_request(self, branch_name: str) -> str:
        """Create a pull request from given branch to the default branch.

        Args:
            branch_name: Branch name from which the pull request will be created.

        Raises:
            RepositoryClientError: if unexpected error occurred during git operation.

        Returns:
            The web url to pull request page.
        """
        try:
            pull_request = self._github_repo.create_pull(
                title=ACTIONS_PULL_REQUEST_TITLE,
                body=ACTIONS_PULL_REQUEST_BODY,
                base=self._github_repo.default_branch,
                head=branch_name,
            )
        except GithubException as exc:
            raise RepositoryClientError(
                f"Unexpected error creating pull request. {exc=!r}"
            ) from exc

        return pull_request.html_url

    def is_dirty(self) -> bool:
        """Check if repository path has any changes including new files.

        Returns:
            True if any changes have occurred.
        """
        return self._git_repo.is_dirty(untracked_files=True)

    def tag_commit(self, tag_name: str, commit_sha: str) -> None:
        """Tag a commit, if the tag already exists, it is deleted first.

        Args:
            tag_name: The name of the tag.
            commit_sha: The SHA of the commit to tag.

        Raises:
            RepositoryClientError: if there is a problem with communicating with GitHub
        """
        try:
            # Delete the tag if it exists
            with suppress(UnknownObjectException):
                tag_ref = self._github_repo.get_git_ref(f"tags/{tag_name}")
                tag_ref.delete()

            # Create the new tag
            tag_object = self._github_repo.create_git_tag(
                tag_name, TAG_MESSAGE, commit_sha, "commit"
            )
            self._github_repo.create_git_ref(f"refs/tags/{tag_name}", tag_object.sha)
        except GithubException as exc:
            raise RepositoryClientError(f"Communication with GitHub failed. {exc=!r}") from exc

    def get_file_content_from_tag(self, path: str, tag_name: str) -> str:
        """Get the content of a file for a specific tag.

        Args:
            path: The path to the file.
            tag_name: The name of the tag.

        Returns:
            The content of the file for the tag.

        Raises:
            RepositoryTagNotFoundError: if the tag could not be found in the repository.
            RepositoryFileNotFoundError: if the file could not be retrieved from GitHub, more than
                one file is returned or a non-file is returned
            RepositoryClientError: if there is a problem with communicating with GitHub
        """
        # Get the tag
        try:
            # Need both steps, the ref allows for retrieval by tag name
            tag_ref = self._github_repo.get_git_ref(f"tags/{tag_name}")
            # The ref does not contain the commit SHA, need to retrieve the tag object
            git_tag = self._github_repo.get_git_tag(tag_ref.object.sha)
        except UnknownObjectException as exc:
            raise RepositoryTagNotFoundError(
                f"Could not retrieve the tag {tag_name=}. {exc=!r}"
            ) from exc
        except GithubException as exc:
            raise RepositoryClientError(f"Communication with GitHub failed. {exc=!r}") from exc

        # Get the file contents
        try:
            content_file = self._github_repo.get_contents(path, git_tag.object.sha)
        except UnknownObjectException as exc:
            raise RepositoryFileNotFoundError(
                f"Could not retrieve the file at {path=} for tag {tag_name}. {exc=!r}"
            ) from exc
        except GithubException as exc:
            raise RepositoryClientError(f"Communication with GitHub failed. {exc=!r}") from exc

        if isinstance(content_file, list):
            raise RepositoryFileNotFoundError(
                f"Path matched more than one file {path=} for tag {tag_name}."
            )

        if content_file.content is None:
            raise RepositoryFileNotFoundError(
                f"Path did not match a file {path=} for tag {tag_name}."
            )

        return base64.b64decode(content_file.content).decode("utf-8")


def _get_repository_name_from_git_url(remote_url: str) -> str:
    """Get repository name from git remote URL.

    Args:
        remote_url: URL of remote repository.
        e.g. https://github.com/canonical/upload-charm-docs.git

    Raises:
        InputError: if invalid repository url was given.

    Returns:
        Git repository name. e.g. canonical/upload-charm-docs.
    """
    matched_repository = HTTPS_URL_PATTERN.match(remote_url)
    if not matched_repository:
        raise InputError(f"Invalid remote repository url {remote_url=!r}")
    return matched_repository.group(1)


def create_repository_client(access_token: str | None, base_path: Path) -> Client:
    """Create a Github instance to handle communication with Github server.

    Args:
        access_token: Access token that has permissions to open a pull request.
        base_path: Path where local .git resides in.

    Raises:
        InputError: if invalid access token or invalid git remote URL is provided.

    Returns:
        A Github repository instance.
    """
    if not access_token:
        raise InputError(
            f"Invalid 'access_token' input, it must be non-empty, got {access_token=!r}"
        )

    local_repo = Repo(base_path)
    logging.info("executing in git repository in the directory: %s", local_repo.working_dir)
    github_client = Github(login_or_token=access_token)
    remote_url = local_repo.remote().url
    repository_fullname = _get_repository_name_from_git_url(remote_url=remote_url)
    remote_repo = github_client.get_repo(repository_fullname)
    return Client(repository=local_repo, github_repository=remote_repo)
